<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Cargo" href="Cargo.html" /><link rel="prev" title="Generic" href="Generic.html" />

    <!-- Generated with Sphinx 6.1.3 and Furo 2022.12.07 -->
        <title>Smart Pointer - Pengenalan Rust Bahasa Indonesia</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Pengenalan Rust Bahasa Indonesia</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">Pengenalan Rust Bahasa Indonesia</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Daftar Isi:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Pengenalan.html">Pengenalan</a></li>
<li class="toctree-l1"><a class="reference internal" href="Variabel.html">Variabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fungsi.html">Fungsi</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ownership.html">Ownership</a></li>
<li class="toctree-l1"><a class="reference internal" href="Enumerasi_dan_Pattern_Matching.html">Enumerasi dan Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tipe_Result_dan_Option.html">Tipe Result dan Option</a></li>
<li class="toctree-l1"><a class="reference internal" href="Kondisional.html">Kondisional</a></li>
<li class="toctree-l1"><a class="reference internal" href="Loop.html">Loop</a></li>
<li class="toctree-l1"><a class="reference internal" href="Struktur_dan_Implementasi.html">Struktur dan Implementasi</a></li>
<li class="toctree-l1"><a class="reference internal" href="Trait.html">Trait</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generic.html">Generic</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Smart Pointer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Cargo.html">Cargo</a></li>
<li class="toctree-l1"><a class="reference internal" href="Crate.html">Crate</a></li>
<li class="toctree-l1"><a class="reference internal" href="Referensi.html">Referensi</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="smart-pointer">
<h1>Smart Pointer<a class="headerlink" href="#smart-pointer" title="Permalink to this heading">#</a></h1>
<section id="box-smart-pointer">
<h2>Box Smart Pointer<a class="headerlink" href="#box-smart-pointer" title="Permalink to this heading">#</a></h2>
<p>Sebuah pointer, sebuah konsep umum untuk sebuah variabel yang menyimpan alamat memory. Alamat memory ini menunjuk - pointing pada sebuah data. Smart Pointer, atau pointer pintar namun, adalah struktur data yang tidak hanya berperilaku seperti sebuah pointer, namun juga memiliki kapabilitas lain. Konsep smart pointer ini berawal dari C++.</p>
<p>Di artikel ini, kita akan membahas penggunaan Box, sebuah smart pointer yang sangat umum digunakan di Rust. Box digunakan untuk menunjuk pada data di heap. Box memiliki kapabilitas untuk mengalokasikan data di heap dan menghapusnya ketika sudah tidak digunakan.</p>
<p>Penggunaan Box adalah sebagai berikut</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn main() {
  let boxed_value = Box::new(10);
  println!(&quot;{}&quot;, boxed_value);
}
</pre></div>
</div>
<p>Dalam kode diatas, kita mengalokasikan 10 yang merupakan sebuah integer - tipe primitif pada heap, yang seharusnya ada pada stack. Box tidak mengimplementasikan <code class="docutils literal notranslate"><span class="pre">Copy</span></code> karena ia bukan tipe primitif sehingga, bila ingin menggunakannya berulang kali, kita harus menggunakan borrow (&amp;), atau clone untuk variabel box.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn main() {
  let boxed_value = Box::new(10);
  let clone_box = boxed_value.clone();
  println!(&quot;{}&quot;, clone_box);
}
</pre></div>
</div>
<section id="penggunaan-box-lebih-mendalam">
<h3>Penggunaan Box Lebih Mendalam<a class="headerlink" href="#penggunaan-box-lebih-mendalam" title="Permalink to this heading">#</a></h3>
<p>Sekarang, lihat <code class="docutils literal notranslate"><span class="pre">enum</span></code> berikut</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#[derive(Debug)]</span>
<span class="n">enum</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Cons</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="n">Nil</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">enum</span></code> di atas merupakan struktur data <code class="docutils literal notranslate"><span class="pre">Cons</span> <span class="pre">List</span></code> yang berasal dari bahasa Lisp. Struktur data diatas akan terus memuat data di dalam varian <code class="docutils literal notranslate"><span class="pre">Cons</span></code> secara rekursif hingga ia menemukan <code class="docutils literal notranslate"><span class="pre">Nil</span></code>. Setelah menemukan <code class="docutils literal notranslate"><span class="pre">Nil</span></code>, ia akan berhenti disana tanpa data apapun lagi. Bila kalian sudah membaca bab <code class="docutils literal notranslate"><span class="pre">enum</span></code>, kalian pasti mengerti cara kerjanya.</p>
<p>Namun, perlu ditegaskan bahwa <code class="docutils literal notranslate"><span class="pre">enum</span></code> di atas tidak akan bekerja. Mengapa?</p>
<p>Rust harus mengetahui berapa besar ruang yang sebuah tipe ambil pada saat compile time. Sedangkan pada <code class="docutils literal notranslate"><span class="pre">enum</span></code> diatas, ia bersifat rekursif yang dalam teori, dia dapat berulang selamanya - tidak terbatas. Ia dapat terus memuat varian <cite>Cons</cite> yang memuat tipe <cite>List</cite> yang berupa varian <code class="docutils literal notranslate"><span class="pre">Cons</span></code> juga dan terus begitu. Rust tidak mengetahui berapa besar si <code class="docutils literal notranslate"><span class="pre">enum</span></code> <code class="docutils literal notranslate"><span class="pre">List</span></code> pada saat compile time.</p>
<p>Mari kita coba mengimplementasikan contoh Cons List diatas lalu kita compile.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, List&lt;T&gt;),
    Nil,
}

use List::*;

fn main() {
    let l = Cons(42, Cons(69, Cons(613, Nil)));

    println!(&quot;{:?}&quot;, l);
}
</pre></div>
</div>
<p>Bila kita mengcompile kode diatas, kita akan mendapatkan error berikut:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>2 | enum List&lt;T&gt; {
  | ^^^^^^^^^^^^ recursive type has infinite size
3 |     Cons(T, List&lt;T&gt;),
  |             ------- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
3 |     Cons(T, Box&lt;List&lt;T&gt;&gt;),
</pre></div>
</div>
<p>Error diatas menunjukkan bahwa kita memiliki tipe rekursif dengan ukuran tidak terbatas - rekursif tanpa indirection. Error diatas juga membantu kita dengan memberitahu bahwa kita harus me-wrap <code class="docutils literal notranslate"><span class="pre">List</span></code> dalam <code class="docutils literal notranslate"><span class="pre">Box</span></code>. Indirection disini berarti daripada kita menyimpan nilai dari <code class="docutils literal notranslate"><span class="pre">List</span></code> yang rekursif secara langsung, kita harus menyimpan sebuah pointer, yang mengarah kepada nilai dari <code class="docutils literal notranslate"><span class="pre">List</span></code> - yaitu <code class="docutils literal notranslate"><span class="pre">Box</span></code> tersebut.</p>
<p>Sebelum kita membahas mengapa Box menyelesaikan masalah diatas, mari kita bahas bagaimana compiler Rust menghitung enum yang non-rekursif.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enum</span> <span class="n">Enum</span> <span class="p">{</span>
  <span class="n">A</span><span class="p">,</span>
  <span class="n">B</span><span class="p">(</span><span class="n">i32</span><span class="p">,</span> <span class="n">i32</span><span class="p">),</span>
  <span class="n">C</span><span class="p">(</span><span class="n">f64</span><span class="p">,</span> <span class="n">i64</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Disini kita memiliki sebuah <code class="docutils literal notranslate"><span class="pre">enum</span></code> dengan 3 varian dimana dua varian memiliki nilai didalamnya. Cara Rust menghitung besar <code class="docutils literal notranslate"><span class="pre">enum</span></code> diatas adalah dengan mengecek setiap varian dan tipe nilai yang dimiliki varian dan mencari varian mana yang membutuhkan ruang paling banyak - atau varian dengan ukuran terbesar. Karena kita hanya bisa menggunakan satu varian dalam satu waktu, maka besar varian yang paling besar akan menjadi besar dari <code class="docutils literal notranslate"><span class="pre">Enum</span></code> itu sendiri.</p>
<p>Namun, untuk <code class="docutils literal notranslate"><span class="pre">Cons</span></code> <code class="docutils literal notranslate"><span class="pre">List</span></code> kita, saat Rust bertemu dengan tipe <code class="docutils literal notranslate"><span class="pre">List</span></code> dalam varian <code class="docutils literal notranslate"><span class="pre">Cons</span></code>, ia akan kembali lagi pada <code class="docutils literal notranslate"><span class="pre">List</span></code>, dan berulang terus seperti itu sehingga tidak ada cara untuk mengetahui berapa besar si varian <code class="docutils literal notranslate"><span class="pre">Cons</span></code> kita dan Rust tidak akan tahu juga berapa besar <code class="docutils literal notranslate"><span class="pre">enum</span></code> <code class="docutils literal notranslate"><span class="pre">List</span></code> kita.</p>
<p>Sekarang, seperti yang Rust compiler sarankan, kita akan me-wrap <code class="docutils literal notranslate"><span class="pre">List</span></code> kita di dalam <code class="docutils literal notranslate"><span class="pre">Box</span></code>. Mari kita lakukan.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

use List::*;

fn main() {

  // Untuk me-wrap nilai dalam Box, gunakan Box::new(nilai)
    let l = Cons(42, Box::new(Cons(69, Box::new(Cons(613, Box::new(Nil))))));

    println!(&quot;{:?}&quot;, l);
}
</pre></div>
</div>
<p>Dan kode kita akan tercompile:
.. code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cons</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">69</span><span class="p">,</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">613</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)))</span>
</pre></div>
</div>
<p>Lalu bagaimanakah <code class="docutils literal notranslate"><span class="pre">Box</span></code> menyelesaikan masalah ini? Pertama-tama, <code class="docutils literal notranslate"><span class="pre">Box</span></code> adalah sebuah pointer. Ukuran dari sebuah pointer itu tetap. Ukuran pointer tidak berdasarkan besar atau jumlah data yang dia tunjuk. <code class="docutils literal notranslate"><span class="pre">Box</span></code> menunjuk pada nilai <code class="docutils literal notranslate"><span class="pre">List</span></code> kita selanjutnya yang berada pada memori heap, bukan pada varian <code class="docutils literal notranslate"><span class="pre">Cons</span></code> sehingga ini akan seperti menaruh sesuatu bersebelahan dengan sesuatu yang lain, bukan menaruh sesuatu didalam sesuatu yang lain dan <code class="docutils literal notranslate"><span class="pre">Box</span></code> menunjuk pada sesuatu yang bersebelahan tersebut yang dalam hal ini adalah nilai dari <code class="docutils literal notranslate"><span class="pre">List</span></code> yang di-wrap dalam <code class="docutils literal notranslate"><span class="pre">Box</span></code> pada varian <code class="docutils literal notranslate"><span class="pre">Cons</span></code>.</p>
<p>Kesimpulan: Pada Rust, <code class="docutils literal notranslate"><span class="pre">usize</span></code> itu pointer-sized sehingga ukuran dari <code class="docutils literal notranslate"><span class="pre">Cons</span></code> adalah ukuran dari tipe yang kita berikan pada genericnya, dan <code class="docutils literal notranslate"><span class="pre">usize</span></code> karena kita menyimpan pointer.</p>
</section>
</section>
<section id="deref-trait">
<h2><cite>Deref</cite> Trait<a class="headerlink" href="#deref-trait" title="Permalink to this heading">#</a></h2>
<p>Sebuah smart pointer adalah sebuah tipe yang mengimplementasikan trait Deref dan trait Drop. Di artikel kali ini, kita akan membahas tentang trait Deref yang membuat kita dapat memperlakukan sebuah pointer seperti sebuah reference biasa. Lalu apa maksud dari memperlakukan sebuah pointer seperti sebuah reference biasa?</p>
<p>Sebelum itu, mari kita membahas lebih lanjut tentang Dereferencing.</p>
<section id="dereferencing">
<h3>Dereferencing<a class="headerlink" href="#dereferencing" title="Permalink to this heading">#</a></h3>
<p>Dereferencing adalah sebuah cara untuk mengakses nilai dari sebuah lokasi memori yang ditunjuk oleh sebuah pointer. Pada Rust, seperti dalam bahasa seperti C++, kita menggunakan operator * untuk dereferencing.</p>
<p>Sekarang, mari kita lihat kode berikut</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn main() {
  let a = 10;
  let b = &amp;a;

  assert_eq!(10, a);
  assert_eq!(10, b);
}
</pre></div>
</div>
<p>Kita menggunakan macro assert_eq! pada kode diatas untuk mengecek apakah sebuah nilai setara (equal) dengan nilai yang lainnya. Namun, hal yang akan terjadi saat kita compile kode diatas adalah compile error yakni sebagai berikut</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>error[E0277]: can&#39;t compare `{integer}` with `&amp;{integer}`
 --&gt; deref.rs:7:2
  |
7 |     assert_eq!(10, b);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
</pre></div>
</div>
<p>Error diatas menyatakan kalau kita tidak bisa membandingkan sebuah integer dengan sebuah reference kepada sebuah integer. Mereka adalah tipe yang berbeda sehingga kita harus menggunakan dereference operator.</p>
<p>Dereference operator menggunakan tanda asterisk (*)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn main() {
  let a = 10;
  let b = &amp;a;

  assert_eq!(10, a);
    assert_eq!(10, *b);
}
</pre></div>
</div>
<p>Pada Rust, sebuah reference (&amp;) sebenarnya juga merupakan pointer. Jadi, variabel b diatas adalah sebuah pointer yang menyimpan alamat memory a dan menunjuk kepada dimana valuenya, 10 disimpan.</p>
<p>Pada assertion pertama, kita membandingkan 10 dan a, yang hasilnya adalah benar. Pada assertion kedua, kita membandingkan 10 dan b yang sudah kita dereference sehingga b disana merupakan value yang ia tunjuk, yaitu 10. Kode akan berjalan dengan baik.</p>
</section>
<section id="apa-itu-trait-deref">
<h3>Apa itu Trait <cite>Deref</cite>?<a class="headerlink" href="#apa-itu-trait-deref" title="Permalink to this heading">#</a></h3>
<p>Kita dapat memperlakukan sebuah smart pointer seperti sebuah reference biasa.</p>
<p>Untuk contoh yang lebih lanjut, kita akan mengganti kode diatas dan menggunakan sebuah smart pointer daripada sebuah reference. Kita akan menggunakan <code class="docutils literal notranslate"><span class="pre">Box&lt;T&gt;</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn main() {
  let a = 10;
  let b = Box::new(a);

  assert_eq!(10, a);
  assert_eq!(10, *b);
}
</pre></div>
</div>
<p>Seperti reference, <code class="docutils literal notranslate"><span class="pre">Box</span></code> juga menunjuk kepada nilai yang disimpan di suatu tempat di memori, yang dalam hal ini adalah <code class="docutils literal notranslate"><span class="pre">10</span></code>. Perbedaannya disini adalah <code class="docutils literal notranslate"><span class="pre">b</span></code> menunjuk pada sebuah copy dari <code class="docutils literal notranslate"><span class="pre">10</span></code> karena value tipe primitif akan di-copy, bukan di-move ownershipnya.</p>
<p><code class="docutils literal notranslate"><span class="pre">Box&lt;T&gt;</span></code> merupakan sebuah smart pointer yang mengimplementasikan trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code>. Inilah yang dimaksud dengan memperlakukan sebuah pointer seperti sebuah reference biasa. Trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code> memperbolehkan dereference operator bekerja pada <code class="docutils literal notranslate"><span class="pre">Box&lt;T&gt;</span></code> sama seperti ia bekerja pada reference biasa.</p>
<p>Untuk mengerti bagaimana itu bekerja, kita akan mendefinisikan sebuah smart pointer kita sendiri yang akan mengimplementasikan <code class="docutils literal notranslate"><span class="pre">Deref</span></code>.</p>
</section>
<section id="mendefinisikan-smart-pointer-kita-sendiri">
<h3>Mendefinisikan smart pointer kita sendiri<a class="headerlink" href="#mendefinisikan-smart-pointer-kita-sendiri" title="Permalink to this heading">#</a></h3>
<p>Kita akan mendefiniskan sebuah smart pointer yang serupa dengan <code class="docutils literal notranslate"><span class="pre">Box&lt;T&gt;</span></code>. Hanya saja, disini kita tidak akan menyimpan nilai pada heap. Disini kita akan berfokus pada dereference operator, bukan dimana lokasi data disimpan.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Kotak</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="n">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Kotak</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">fn</span> <span class="n">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
    <span class="n">Self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sekarang, kita ganti <code class="docutils literal notranslate"><span class="pre">Box&lt;T&gt;</span></code> di fungsi main dengan <code class="docutils literal notranslate"><span class="pre">Kotak&lt;T&gt;</span></code> kita.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn main() {
  let a = 10;
  let b = Kotak::new(a);

  assert_eq!(10, a);
  assert_eq!(10, *b);
}
</pre></div>
</div>
<p>Namun pada kode diatas, kita akan mendapatkan error dimana kita tidak bisa melakukan dereference pada tipe <code class="docutils literal notranslate"><span class="pre">Kotak</span></code> kita. Sekarang, mari kita implementasikan trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code>.</p>
</section>
<section id="mengimplementasikan-deref-pada-smart-pointer-kita">
<h3>Mengimplementasikan <cite>Deref</cite> pada smart pointer kita<a class="headerlink" href="#mengimplementasikan-deref-pada-smart-pointer-kita" title="Permalink to this heading">#</a></h3>
<p>Pertama-tama. panggil trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code> di baris paling atas kode.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">std</span><span class="p">::</span><span class="n">ops</span><span class="p">::</span><span class="n">Deref</span><span class="p">;</span>
</pre></div>
</div>
<p>Lalu kita implementasikan pada <code class="docutils literal notranslate"><span class="pre">Kotak&lt;T&gt;</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">Kotak</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nb">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

  <span class="n">fn</span> <span class="n">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
    <span class="o">&amp;</span><span class="bp">self</span><span class="mf">.0</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Kalian tidak perlu terlalu mengkhawatirkan <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">Target</span> <span class="pre">=</span> <span class="pre">T</span></code> untuk sekarang. Itu adalah sebuah associated type yang akan kita bahas di lain waktu. Kalian juga bisa mengganti return type method <code class="docutils literal notranslate"><span class="pre">deref</span></code> menjadi hanya <code class="docutils literal notranslate"><span class="pre">&amp;T</span></code>.</p>
<p>Trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code> mengharuskan kita untuk mengimplementasikan satu method bernama <code class="docutils literal notranslate"><span class="pre">deref</span></code> yang menerima <code class="docutils literal notranslate"><span class="pre">&amp;self</span></code>, dan mengembalikan sebuah reference kepada inner data atau data didalam <code class="docutils literal notranslate"><span class="pre">struct</span></code> kita. Ingat, kita disini memakai <code class="docutils literal notranslate"><span class="pre">tuple</span> <span class="pre">struct</span></code> yang menggunakan index 0, 1, dan seterusnya untuk mengambil inner data.</p>
<p>Sekarang, kode kita akan terlihat seperti ini</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>use std::ops::Deref;

struct Kotak&lt;T&gt;(T);

impl&lt;T&gt; Kotak&lt;T&gt; {
    fn new(x: T) -&gt; Self {
        Self(x)
    }
}

impl&lt;T&gt; Deref for Kotak&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

fn main() {
    let a = 10;
    let b = Kotak::new(a);

    assert_eq!(10, a);
    assert_eq!(10, *b);
}
</pre></div>
</div>
<p>Dan assertion kedua kita akan berhasil. Kita akan dapat melakukan dereference pada tipe <code class="docutils literal notranslate"><span class="pre">Kotak</span></code> kita. Kode akan dapat kita compile.</p>
<p>Tanpa trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code>, compiler hanya mengetahui cara dereference reference saja. Trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code> membuat compiler Rust untuk memanggil method <code class="docutils literal notranslate"><span class="pre">deref</span></code> untuk semua tipe yang mengimplementasikannya - untuk mendapatkan sebuah reference kepada sebuah nilai (Self::Target atau &amp;T kita diatas), yang si compiler tahu bagaimana cara dereferencenya.</p>
<p>Saat kita menggunakan operator dereference kepada sebuah nilai yang telah mengimplementasikan trait <cite>Deref</cite>, assertion kedua kita di atas contohnya, sebenarnya Rust memanggil kode seperti berikut:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>assert_eq!(10, *(b.deref()));
</pre></div>
</div>
<p>Rust akan memanggil method <code class="docutils literal notranslate"><span class="pre">deref</span></code> terlebih dahulu untuk mendapatkan reference kepada nilai kita, yang pada kasus diatas adalah <code class="docutils literal notranslate"><span class="pre">10</span></code>, lalu melakukan dereferencing dengan operator dereference sehingga kira-kira hal yang terjadi adalah berikut:</p>
<p><code class="docutils literal notranslate"><span class="pre">Kotak(10)</span> <span class="pre">-&gt;</span> <span class="pre">deref()</span> <span class="pre">terpanggil</span> <span class="pre">-&gt;</span> <span class="pre">&amp;10</span> <span class="pre">-&gt;</span> <span class="pre">dereference</span> <span class="pre">operator</span> <span class="pre">digunakan</span> <span class="pre">-&gt;</span> <span class="pre">10</span></code></p>
<p>Karena Rust melakukan hal itu secara otomatis, kita tidak perlu memikirkan perlu atau tidaknya memanggil method <code class="docutils literal notranslate"><span class="pre">deref</span></code> secara eksplisit sehingga kita bisa memperlakukan reference biasa, dan sebuah tipe yang mengimplementasikan trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code> dengan sama.</p>
<p>Lalu kenapa method <code class="docutils literal notranslate"><span class="pre">deref</span></code> mengembalikan reference kepada suatu nilai bukan nilainya itu sendiri?</p>
<p>Tentunya itu berhubungan dengan ownership pada Rust. Kalau <code class="docutils literal notranslate"><span class="pre">deref</span></code> mengembalikan nilainya secara langsung, maka ownership dari nilai tersebut akan di-move keluar dari tipe kita, yang dalam kasus ini, smart pointer kita Kotak&lt;T&gt;. Dan di banyak kasus saat kita menggunakan operator dereference, kita tidak mau itu terjadi.</p>
</section>
</section>
<section id="deref-coercion">
<h2>Deref Coercion<a class="headerlink" href="#deref-coercion" title="Permalink to this heading">#</a></h2>
<p>Kita telah melihat bagaimana trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code> bekerja. Sekarang, kita akan melihat bagaimana trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code> bekerja dengan <code class="docutils literal notranslate"><span class="pre">Deref</span> <span class="pre">Coercion</span></code>.</p>
<p>Deref Coercion adalah sebuah fitur sangat praktis yang Rust akan secara otomatis gunakan pada dan hanya pada tipe yang mengimplementasikan trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code> ketika tipe tersebut dijadikan argumen untuk fungsi atau method. Deref Coercion akan mengubah sebuah reference dari satu tipe kepada sebuah reference dari tipe yang berbeda.</p>
<p>Untuk lebih jelasnya, mari kita lanjutkan kode diatas dengan menambahkan sebuah prosedur untuk mencetak <cite>&amp;str</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn main() {
    let a = 10;
    let b = Kotak::new(a);

    assert_eq!(10, a);
    assert_eq!(10, *b);
}

fn prosedur(a: &amp;str) {
  println!(&quot;A adalah: {}&quot;, a);
}
</pre></div>
</div>
<p>Sekarang, kita akan membuat sebuah variabel baru yang menggunakan smart pointer <code class="docutils literal notranslate"><span class="pre">Kotak&lt;T&gt;</span></code> kita dan sebuah <cite>String</cite> untuk nilai didalam <code class="docutils literal notranslate"><span class="pre">Kotak&lt;T&gt;</span></code> kita, lalu kita panggil prosedur kita dengan variabel tersebut sebagai argumen.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fn main() {
    let a = 10;
    let b = Kotak::new(a);

    assert_eq!(10, a);
    assert_eq!(10, *b);

    let c = Kotak::new(String::from(&quot;Hai&quot;));
    prosedur(&amp;c);
}

fn prosedur(a: &amp;str) {
  println!(&quot;A adalah: {}&quot;, a);
}
</pre></div>
</div>
<p>Seperti yang kalian lihat, prosedur <code class="docutils literal notranslate"><span class="pre">prosedur</span></code> menerima <code class="docutils literal notranslate"><span class="pre">&amp;str</span></code> sebagai argumen. Diatas, kita memberikannya sebuah reference kepada <code class="docutils literal notranslate"><span class="pre">Kotak&lt;T&gt;</span></code> yang memiliki <code class="docutils literal notranslate"><span class="pre">String</span></code> didalamnya. Namun, kode diatas tidak akan error! Kode diatas akan berjalan dengan sempurna.</p>
<p>Apa yang terjadi disini?</p>
<p>Inilah yang terjadi:</p>
<p>Saat kita memakai operator reference di argumen prosedur pada variabel <code class="docutils literal notranslate"><span class="pre">c</span></code>, method <code class="docutils literal notranslate"><span class="pre">deref</span></code> akan terpanggil dan kita akan mendapatkan sebuah reference kepada <code class="docutils literal notranslate"><span class="pre">String</span></code>, nilai yang kita wrap dalam <code class="docutils literal notranslate"><span class="pre">Kotak&lt;T&gt;</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="n">Kotak</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">String</span>
</pre></div>
</div>
<p>Lalu, karena <code class="docutils literal notranslate"><span class="pre">String</span></code> juga mengimplementasikan trait <code class="docutils literal notranslate"><span class="pre">Deref</span></code>, bila kita menggunakan operator dereference, <code class="docutils literal notranslate"><span class="pre">String</span></code> akan mengembalikan sebuah <code class="docutils literal notranslate"><span class="pre">&amp;str</span></code> sehingga hal yang akan terjadi berikutnya adalah:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="n">Kotak</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">String</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span>
</pre></div>
</div>
<p>Rust melakukannya dengan otomatis. Tanpa Deref Coercion, bila ingin melakukan hal seperti diatas, kita harus menuliskannya seperti ini:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prosedur</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)[</span><span class="o">..</span><span class="p">]);</span>
</pre></div>
</div>
<p>Disana kita melakukan dereference pada <code class="docutils literal notranslate"><span class="pre">c</span></code> sehingga kita mendapat sebuah <code class="docutils literal notranslate"><span class="pre">String</span></code>, kemudian <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> dan <code class="docutils literal notranslate"><span class="pre">[..]</span></code> (<code class="docutils literal notranslate"><span class="pre">slice</span></code> yang berisi operator <code class="docutils literal notranslate"><span class="pre">RangeFull</span></code>) akan membuat sebuah <code class="docutils literal notranslate"><span class="pre">&amp;str</span></code> dari si <code class="docutils literal notranslate"><span class="pre">String</span></code> yang setara dengan panjang penuh (full range) si <code class="docutils literal notranslate"><span class="pre">String</span></code>. Sangat merepotkan bukan? Kode akan lebih sulit ditulis dan lebih sulit dibaca. Terima kasih Deref Coercion!</p>
<p>Untuk mutable reference, kita harus menggunakan trait <code class="docutils literal notranslate"><span class="pre">DerefMut</span></code>.</p>
<p>Rust melakukan Deref Coercion bila ia bertemu tipe dan implementasi trait dalam tiga kasus:</p>
<ul class="simple">
<li><p>Dari <code class="docutils literal notranslate"><span class="pre">&amp;T</span></code> ke <code class="docutils literal notranslate"><span class="pre">&amp;U</span></code> ketika <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">Deref&lt;Target=U&gt;</span></code></p></li>
<li><p>Dari <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">T</span></code> ke <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">U</span></code> ketika <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">DerefMut&lt;Target=U&gt;</span></code></p></li>
<li><p>Dari <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">T</span></code> ke <code class="docutils literal notranslate"><span class="pre">&amp;U</span></code> ketika <code class="docutils literal notranslate"><span class="pre">T:</span> <span class="pre">Deref&lt;Target=U&gt;</span></code></p></li>
</ul>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="Cargo.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Cargo</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="Generic.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Generic</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, mukharomdev
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Smart Pointer</a><ul>
<li><a class="reference internal" href="#box-smart-pointer">Box Smart Pointer</a><ul>
<li><a class="reference internal" href="#penggunaan-box-lebih-mendalam">Penggunaan Box Lebih Mendalam</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deref-trait"><cite>Deref</cite> Trait</a><ul>
<li><a class="reference internal" href="#dereferencing">Dereferencing</a></li>
<li><a class="reference internal" href="#apa-itu-trait-deref">Apa itu Trait <cite>Deref</cite>?</a></li>
<li><a class="reference internal" href="#mendefinisikan-smart-pointer-kita-sendiri">Mendefinisikan smart pointer kita sendiri</a></li>
<li><a class="reference internal" href="#mengimplementasikan-deref-pada-smart-pointer-kita">Mengimplementasikan <cite>Deref</cite> pada smart pointer kita</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deref-coercion">Deref Coercion</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/scripts/furo.js"></script>
    </body>
</html>